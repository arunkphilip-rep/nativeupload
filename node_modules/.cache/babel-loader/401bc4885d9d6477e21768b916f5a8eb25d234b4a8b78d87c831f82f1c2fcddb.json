{"ast":null,"code":"export const convertToWav = async (audioChunks, sampleRate = 44100) => {\n  try {\n    console.log('Converting audio chunks:', audioChunks.length);\n    const blob = new Blob(audioChunks);\n    console.log('Initial blob size:', blob.size);\n    const arrayBuffer = await blob.arrayBuffer();\n    const audioContext = new (window.AudioContext || window.webkitAudioContext)({\n      sampleRate: sampleRate\n    });\n    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);\n    console.log('Audio decoded:', {\n      duration: audioBuffer.duration,\n      channels: audioBuffer.numberOfChannels,\n      sampleRate: audioBuffer.sampleRate\n    });\n    const wavBuffer = audioBufferToWav(audioBuffer);\n    const wavBlob = new Blob([wavBuffer], {\n      type: 'audio/wav'\n    });\n    console.log('WAV conversion complete. Size:', wavBlob.size);\n    return wavBlob;\n  } catch (error) {\n    console.error('Error converting audio:', error);\n    throw error;\n  }\n};\nfunction audioBufferToWav(audioBuffer) {\n  const numChannels = audioBuffer.numberOfChannels;\n  const sampleRate = audioBuffer.sampleRate;\n  const format = 1; // PCM\n  const bitDepth = 16;\n  const bytesPerSample = bitDepth / 8;\n  const blockAlign = numChannels * bytesPerSample;\n  const buffer = audioBuffer.getChannelData(0);\n  const length = buffer.length;\n  const byteRate = sampleRate * blockAlign;\n  const dataSize = length * blockAlign;\n  const headerSize = 44;\n  const totalSize = headerSize + dataSize;\n  const wav = new ArrayBuffer(totalSize);\n  const view = new DataView(wav);\n\n  // Write WAV header\n  writeString(view, 0, 'RIFF');\n  view.setUint32(4, 36 + dataSize, true);\n  writeString(view, 8, 'WAVE');\n  writeString(view, 12, 'fmt ');\n  view.setUint32(16, 16, true);\n  view.setUint16(20, format, true);\n  view.setUint16(22, numChannels, true);\n  view.setUint32(24, sampleRate, true);\n  view.setUint32(28, byteRate, true);\n  view.setUint16(32, blockAlign, true);\n  view.setUint16(34, bitDepth, true);\n  writeString(view, 36, 'data');\n  view.setUint32(40, dataSize, true);\n\n  // Write audio data\n  floatTo16BitPCM(view, headerSize, audioBuffer);\n  return wav;\n}\nfunction writeString(view, offset, string) {\n  for (let i = 0; i < string.length; i++) {\n    view.setUint8(offset + i, string.charCodeAt(i));\n  }\n}\nfunction floatTo16BitPCM(view, offset, audioBuffer) {\n  const channels = audioBuffer.numberOfChannels;\n  let index = offset;\n  const length = audioBuffer.length;\n  for (let i = 0; i < length; i++) {\n    for (let channel = 0; channel < channels; channel++) {\n      const sample = Math.max(-1, Math.min(1, audioBuffer.getChannelData(channel)[i]));\n      view.setInt16(index, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);\n      index += 2;\n    }\n  }\n}","map":{"version":3,"names":["convertToWav","audioChunks","sampleRate","console","log","length","blob","Blob","size","arrayBuffer","audioContext","window","AudioContext","webkitAudioContext","audioBuffer","decodeAudioData","duration","channels","numberOfChannels","wavBuffer","audioBufferToWav","wavBlob","type","error","numChannels","format","bitDepth","bytesPerSample","blockAlign","buffer","getChannelData","byteRate","dataSize","headerSize","totalSize","wav","ArrayBuffer","view","DataView","writeString","setUint32","setUint16","floatTo16BitPCM","offset","string","i","setUint8","charCodeAt","index","channel","sample","Math","max","min","setInt16"],"sources":["C:/Users/arunk/Downloads/createxyz-project/ract/audio-recorder/src/utils/audioConverter.js"],"sourcesContent":["export const convertToWav = async (audioChunks, sampleRate = 44100) => {\r\n  try {\r\n    console.log('Converting audio chunks:', audioChunks.length);\r\n    const blob = new Blob(audioChunks);\r\n    console.log('Initial blob size:', blob.size);\r\n    \r\n    const arrayBuffer = await blob.arrayBuffer();\r\n    const audioContext = new (window.AudioContext || window.webkitAudioContext)({\r\n      sampleRate: sampleRate\r\n    });\r\n    \r\n    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);\r\n    console.log('Audio decoded:', {\r\n      duration: audioBuffer.duration,\r\n      channels: audioBuffer.numberOfChannels,\r\n      sampleRate: audioBuffer.sampleRate\r\n    });\r\n    \r\n    const wavBuffer = audioBufferToWav(audioBuffer);\r\n    const wavBlob = new Blob([wavBuffer], { type: 'audio/wav' });\r\n    console.log('WAV conversion complete. Size:', wavBlob.size);\r\n    \r\n    return wavBlob;\r\n  } catch (error) {\r\n    console.error('Error converting audio:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\nfunction audioBufferToWav(audioBuffer) {\r\n  const numChannels = audioBuffer.numberOfChannels;\r\n  const sampleRate = audioBuffer.sampleRate;\r\n  const format = 1; // PCM\r\n  const bitDepth = 16;\r\n  \r\n  const bytesPerSample = bitDepth / 8;\r\n  const blockAlign = numChannels * bytesPerSample;\r\n  \r\n  const buffer = audioBuffer.getChannelData(0);\r\n  const length = buffer.length;\r\n  const byteRate = sampleRate * blockAlign;\r\n  const dataSize = length * blockAlign;\r\n  const headerSize = 44;\r\n  const totalSize = headerSize + dataSize;\r\n  \r\n  const wav = new ArrayBuffer(totalSize);\r\n  const view = new DataView(wav);\r\n  \r\n  // Write WAV header\r\n  writeString(view, 0, 'RIFF');\r\n  view.setUint32(4, 36 + dataSize, true);\r\n  writeString(view, 8, 'WAVE');\r\n  writeString(view, 12, 'fmt ');\r\n  view.setUint32(16, 16, true);\r\n  view.setUint16(20, format, true);\r\n  view.setUint16(22, numChannels, true);\r\n  view.setUint32(24, sampleRate, true);\r\n  view.setUint32(28, byteRate, true);\r\n  view.setUint16(32, blockAlign, true);\r\n  view.setUint16(34, bitDepth, true);\r\n  writeString(view, 36, 'data');\r\n  view.setUint32(40, dataSize, true);\r\n  \r\n  // Write audio data\r\n  floatTo16BitPCM(view, headerSize, audioBuffer);\r\n  \r\n  return wav;\r\n}\r\n\r\nfunction writeString(view, offset, string) {\r\n  for (let i = 0; i < string.length; i++) {\r\n    view.setUint8(offset + i, string.charCodeAt(i));\r\n  }\r\n}\r\n\r\nfunction floatTo16BitPCM(view, offset, audioBuffer) {\r\n  const channels = audioBuffer.numberOfChannels;\r\n  let index = offset;\r\n  const length = audioBuffer.length;\r\n  \r\n  for (let i = 0; i < length; i++) {\r\n    for (let channel = 0; channel < channels; channel++) {\r\n      const sample = Math.max(-1, Math.min(1, audioBuffer.getChannelData(channel)[i]));\r\n      view.setInt16(index, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);\r\n      index += 2;\r\n    }\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}