{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\arunk\\\\Downloads\\\\createxyz-project\\\\ract\\\\audio-recorder\\\\src\\\\AudioRecorder.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useRef, useEffect } from 'react';\nimport { FaMicrophone, FaMicrophoneSlash, FaPlay, FaSpinner } from 'react-icons/fa';\nimport { AUDIO_CONFIG } from './config/constants';\nimport './AudioRecorder.css';\nimport { convertToWav } from './utils/audioConverter';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst AudioRecorder = () => {\n  _s();\n  const [isRecording, setIsRecording] = useState(false);\n  const [audioChunks, setAudioChunks] = useState([]);\n  const [silenceDetected, setSilenceDetected] = useState(false);\n  const [silenceStartTime, setSilenceStartTime] = useState(null);\n  const [transcription, setTranscription] = useState(null);\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [isLoading, setIsLoading] = useState(false);\n  const mediaRecorderRef = useRef(null);\n  const streamRef = useRef(null);\n  const analyserRef = useRef(null);\n  const audioContextRef = useRef(null);\n  const silenceTimeoutRef = useRef(null);\n  const audioPlayerRef = useRef(null);\n  const startRecording = async () => {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: true\n      });\n      streamRef.current = stream;\n      const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n      audioContextRef.current = audioContext;\n      const analyser = audioContext.createAnalyser();\n      analyserRef.current = analyser;\n      analyser.smoothingTimeConstant = AUDIO_CONFIG.SMOOTHING_TIME_CONSTANT;\n      analyser.fftSize = 2048;\n      const source = audioContext.createMediaStreamSource(stream);\n      source.connect(analyser);\n\n      // Get supported MIME type\n      const mimeType = ['audio/webm;codecs=opus', 'audio/webm', 'audio/ogg;codecs=opus', 'audio/ogg'].find(type => MediaRecorder.isTypeSupported(type));\n      if (!mimeType) {\n        throw new Error('No supported media recording MIME type found');\n      }\n      const mediaRecorder = new MediaRecorder(stream, {\n        mimeType,\n        audioBitsPerSecond: 128000\n      });\n      mediaRecorderRef.current = mediaRecorder;\n      mediaRecorder.ondataavailable = event => {\n        if (event.data.size > 0) {\n          setAudioChunks(prevChunks => [...prevChunks, event.data]);\n        }\n      };\n      mediaRecorder.start(AUDIO_CONFIG.CHUNK_INTERVAL);\n      setIsRecording(true);\n      monitorAudioLevel();\n    } catch (err) {\n      console.error(\"Error accessing microphone:\", err);\n      alert('Error accessing microphone. Please check permissions.');\n    }\n  };\n  const stopRecording = () => {\n    if (mediaRecorderRef.current && streamRef.current) {\n      mediaRecorderRef.current.stop();\n      streamRef.current.getTracks().forEach(track => track.stop());\n      if (audioChunks.length > 0) {\n        saveAndSendAudio(audioChunks);\n      }\n      clearTimeout(silenceTimeoutRef.current);\n      setIsRecording(false);\n      setSilenceDetected(false);\n      setSilenceStartTime(null);\n      setAudioChunks([]);\n      if (audioContextRef.current) {\n        audioContextRef.current.close();\n      }\n    }\n  };\n  const toggleRecording = () => {\n    if (isRecording) {\n      stopRecording();\n    } else {\n      startRecording();\n    }\n  };\n  const monitorAudioLevel = () => {\n    if (!analyserRef.current || !isRecording) return;\n    const dataArray = new Uint8Array(analyserRef.current.frequencyBinCount);\n    analyserRef.current.getByteFrequencyData(dataArray);\n    const average = dataArray.reduce((a, b) => a + b, 0) / dataArray.length;\n    const dB = 20 * Math.log10(average / 255);\n    if (dB < AUDIO_CONFIG.SILENCE_THRESHOLD) {\n      if (!silenceDetected) {\n        setSilenceDetected(true);\n        setSilenceStartTime(Date.now());\n      } else if (Date.now() - silenceStartTime > AUDIO_CONFIG.SILENCE_DURATION) {\n        saveAndSendAudio(audioChunks);\n        setSilenceStartTime(Date.now());\n      }\n    } else {\n      setSilenceDetected(false);\n      setSilenceStartTime(null);\n    }\n    requestAnimationFrame(monitorAudioLevel);\n  };\n  const saveAndSendAudio = async chunks => {\n    if (!chunks || chunks.length === 0) return;\n    try {\n      var _audioContextRef$curr;\n      setIsLoading(true);\n      const wavBlob = await convertToWav(chunks, ((_audioContextRef$curr = audioContextRef.current) === null || _audioContextRef$curr === void 0 ? void 0 : _audioContextRef$curr.sampleRate) || AUDIO_CONFIG.SAMPLE_RATE);\n      const formData = new FormData();\n      formData.append('audio', wavBlob, `recording_${Date.now()}.wav`);\n      const response = await fetch(`${AUDIO_CONFIG.BACKEND_URL}${AUDIO_CONFIG.API_ENDPOINTS.UPLOAD}`, {\n        method: 'POST',\n        body: formData\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const result = await response.json();\n      console.log('Upload result:', result);\n      if (result.transcription_file) {\n        await pollTranscription(result.transcription_file);\n      }\n      setAudioChunks([]);\n    } catch (error) {\n      console.error('Error processing/sending audio:', error);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n  const pollTranscription = async filename => {\n    const maxAttempts = 30;\n    let attempts = 0;\n    while (attempts < maxAttempts) {\n      try {\n        const response = await fetch(`${AUDIO_CONFIG.BACKEND_URL}${AUDIO_CONFIG.API_ENDPOINTS.TRANSCRIPTION}/${filename}`);\n        if (response.ok) {\n          const data = await response.json();\n          setTranscription(data);\n          return;\n        }\n        // Only log on specific errors, not 404\n        if (response.status !== 404) {\n          console.error('Polling error:', response.status);\n        }\n      } catch (error) {\n        console.error('Polling error:', error);\n      }\n      attempts++;\n      await new Promise(resolve => setTimeout(resolve, 2000)); // Increased interval to 2 seconds\n    }\n    console.log('Polling timeout reached');\n  };\n  const playTTSAudio = async () => {\n    if (!(transcription !== null && transcription !== void 0 && transcription.tts_audio)) return;\n    try {\n      if (!audioPlayerRef.current) {\n        const audioUrl = `${AUDIO_CONFIG.BACKEND_URL}${AUDIO_CONFIG.API_ENDPOINTS.TTS}/${transcription.tts_audio}`;\n        audioPlayerRef.current = new Audio(audioUrl);\n      }\n      setIsPlaying(true);\n      await audioPlayerRef.current.play();\n      audioPlayerRef.current.onended = () => {\n        setIsPlaying(false);\n      };\n    } catch (error) {\n      console.error('Error playing TTS:', error);\n      setIsPlaying(false);\n    }\n  };\n  useEffect(() => {\n    return () => {\n      if (isRecording) {\n        stopRecording();\n      }\n    };\n  }, []);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"audio-recorder\",\n    children: [/*#__PURE__*/_jsxDEV(\"button\", {\n      className: `record-button ${isRecording ? 'recording' : ''}`,\n      onClick: toggleRecording,\n      children: isRecording ? /*#__PURE__*/_jsxDEV(FaMicrophoneSlash, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 221,\n        columnNumber: 24\n      }, this) : /*#__PURE__*/_jsxDEV(FaMicrophone, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 221,\n        columnNumber: 48\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 217,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"status\",\n      children: isRecording ? /*#__PURE__*/_jsxDEV(\"span\", {\n        className: \"recording-indicator\",\n        children: [\"Recording \", silenceDetected ? '(Silence detected)' : '']\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 225,\n        columnNumber: 11\n      }, this) : /*#__PURE__*/_jsxDEV(\"span\", {\n        children: \"Click to start recording\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 229,\n        columnNumber: 11\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 223,\n      columnNumber: 7\n    }, this), transcription && /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"transcription-section\",\n      children: [/*#__PURE__*/_jsxDEV(\"p\", {\n        className: \"transcription-text\",\n        children: transcription.full_text\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 235,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        className: `tts-button ${isPlaying ? 'playing' : ''}`,\n        onClick: playTTSAudio,\n        disabled: isPlaying || isLoading,\n        children: [isLoading ? /*#__PURE__*/_jsxDEV(FaSpinner, {\n          className: \"spinner\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 241,\n          columnNumber: 26\n        }, this) : /*#__PURE__*/_jsxDEV(FaPlay, {}, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 241,\n          columnNumber: 62\n        }, this), isPlaying ? 'Playing...' : 'Play TTS']\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 236,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 234,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 216,\n    columnNumber: 5\n  }, this);\n};\n_s(AudioRecorder, \"CQKwoWSAYUgboWruQQ8clJlkCXs=\");\n_c = AudioRecorder;\nexport default AudioRecorder;\nvar _c;\n$RefreshReg$(_c, \"AudioRecorder\");","map":{"version":3,"names":["React","useState","useRef","useEffect","FaMicrophone","FaMicrophoneSlash","FaPlay","FaSpinner","AUDIO_CONFIG","convertToWav","jsxDEV","_jsxDEV","AudioRecorder","_s","isRecording","setIsRecording","audioChunks","setAudioChunks","silenceDetected","setSilenceDetected","silenceStartTime","setSilenceStartTime","transcription","setTranscription","isPlaying","setIsPlaying","isLoading","setIsLoading","mediaRecorderRef","streamRef","analyserRef","audioContextRef","silenceTimeoutRef","audioPlayerRef","startRecording","stream","navigator","mediaDevices","getUserMedia","audio","current","audioContext","window","AudioContext","webkitAudioContext","analyser","createAnalyser","smoothingTimeConstant","SMOOTHING_TIME_CONSTANT","fftSize","source","createMediaStreamSource","connect","mimeType","find","type","MediaRecorder","isTypeSupported","Error","mediaRecorder","audioBitsPerSecond","ondataavailable","event","data","size","prevChunks","start","CHUNK_INTERVAL","monitorAudioLevel","err","console","error","alert","stopRecording","stop","getTracks","forEach","track","length","saveAndSendAudio","clearTimeout","close","toggleRecording","dataArray","Uint8Array","frequencyBinCount","getByteFrequencyData","average","reduce","a","b","dB","Math","log10","SILENCE_THRESHOLD","Date","now","SILENCE_DURATION","requestAnimationFrame","chunks","_audioContextRef$curr","wavBlob","sampleRate","SAMPLE_RATE","formData","FormData","append","response","fetch","BACKEND_URL","API_ENDPOINTS","UPLOAD","method","body","ok","status","result","json","log","transcription_file","pollTranscription","filename","maxAttempts","attempts","TRANSCRIPTION","Promise","resolve","setTimeout","playTTSAudio","tts_audio","audioUrl","TTS","Audio","play","onended","className","children","onClick","fileName","_jsxFileName","lineNumber","columnNumber","full_text","disabled","_c","$RefreshReg$"],"sources":["C:/Users/arunk/Downloads/createxyz-project/ract/audio-recorder/src/AudioRecorder.js"],"sourcesContent":["import React, { useState, useRef, useEffect } from 'react';\r\nimport { FaMicrophone, FaMicrophoneSlash, FaPlay, FaSpinner } from 'react-icons/fa';\r\nimport { AUDIO_CONFIG } from './config/constants';\r\nimport './AudioRecorder.css';\r\nimport { convertToWav } from './utils/audioConverter';\r\n\r\nconst AudioRecorder = () => {\r\n  const [isRecording, setIsRecording] = useState(false);\r\n  const [audioChunks, setAudioChunks] = useState([]);\r\n  const [silenceDetected, setSilenceDetected] = useState(false);\r\n  const [silenceStartTime, setSilenceStartTime] = useState(null);\r\n  const [transcription, setTranscription] = useState(null);\r\n  const [isPlaying, setIsPlaying] = useState(false);\r\n  const [isLoading, setIsLoading] = useState(false);\r\n  \r\n  const mediaRecorderRef = useRef(null);\r\n  const streamRef = useRef(null);\r\n  const analyserRef = useRef(null);\r\n  const audioContextRef = useRef(null);\r\n  const silenceTimeoutRef = useRef(null);\r\n  const audioPlayerRef = useRef(null);\r\n\r\n  const startRecording = async () => {\r\n    try {\r\n      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\r\n      streamRef.current = stream;\r\n      \r\n      const audioContext = new (window.AudioContext || window.webkitAudioContext)();\r\n      audioContextRef.current = audioContext;\r\n      \r\n      const analyser = audioContext.createAnalyser();\r\n      analyserRef.current = analyser;\r\n      analyser.smoothingTimeConstant = AUDIO_CONFIG.SMOOTHING_TIME_CONSTANT;\r\n      analyser.fftSize = 2048;\r\n      \r\n      const source = audioContext.createMediaStreamSource(stream);\r\n      source.connect(analyser);\r\n      \r\n      // Get supported MIME type\r\n      const mimeType = [\r\n        'audio/webm;codecs=opus',\r\n        'audio/webm',\r\n        'audio/ogg;codecs=opus',\r\n        'audio/ogg'\r\n      ].find(type => MediaRecorder.isTypeSupported(type));\r\n      \r\n      if (!mimeType) {\r\n        throw new Error('No supported media recording MIME type found');\r\n      }\r\n      \r\n      const mediaRecorder = new MediaRecorder(stream, {\r\n        mimeType,\r\n        audioBitsPerSecond: 128000\r\n      });\r\n      mediaRecorderRef.current = mediaRecorder;\r\n      \r\n      mediaRecorder.ondataavailable = (event) => {\r\n        if (event.data.size > 0) {\r\n          setAudioChunks((prevChunks) => [...prevChunks, event.data]);\r\n        }\r\n      };\r\n      \r\n      mediaRecorder.start(AUDIO_CONFIG.CHUNK_INTERVAL);\r\n      setIsRecording(true);\r\n      monitorAudioLevel();\r\n      \r\n    } catch (err) {\r\n      console.error(\"Error accessing microphone:\", err);\r\n      alert('Error accessing microphone. Please check permissions.');\r\n    }\r\n  };\r\n\r\n  const stopRecording = () => {\r\n    if (mediaRecorderRef.current && streamRef.current) {\r\n      mediaRecorderRef.current.stop();\r\n      streamRef.current.getTracks().forEach(track => track.stop());\r\n      \r\n      if (audioChunks.length > 0) {\r\n        saveAndSendAudio(audioChunks);\r\n      }\r\n      \r\n      clearTimeout(silenceTimeoutRef.current);\r\n      setIsRecording(false);\r\n      setSilenceDetected(false);\r\n      setSilenceStartTime(null);\r\n      setAudioChunks([]);\r\n      \r\n      if (audioContextRef.current) {\r\n        audioContextRef.current.close();\r\n      }\r\n    }\r\n  };\r\n\r\n  const toggleRecording = () => {\r\n    if (isRecording) {\r\n      stopRecording();\r\n    } else {\r\n      startRecording();\r\n    }\r\n  };\r\n\r\n  const monitorAudioLevel = () => {\r\n    if (!analyserRef.current || !isRecording) return;\r\n    \r\n    const dataArray = new Uint8Array(analyserRef.current.frequencyBinCount);\r\n    analyserRef.current.getByteFrequencyData(dataArray);\r\n    \r\n    const average = dataArray.reduce((a, b) => a + b, 0) / dataArray.length;\r\n    const dB = 20 * Math.log10(average / 255);\r\n    \r\n    if (dB < AUDIO_CONFIG.SILENCE_THRESHOLD) {\r\n      if (!silenceDetected) {\r\n        setSilenceDetected(true);\r\n        setSilenceStartTime(Date.now());\r\n      } else if (Date.now() - silenceStartTime > AUDIO_CONFIG.SILENCE_DURATION) {\r\n        saveAndSendAudio(audioChunks);\r\n        setSilenceStartTime(Date.now());\r\n      }\r\n    } else {\r\n      setSilenceDetected(false);\r\n      setSilenceStartTime(null);\r\n    }\r\n    \r\n    requestAnimationFrame(monitorAudioLevel);\r\n  };\r\n\r\n  const saveAndSendAudio = async (chunks) => {\r\n    if (!chunks || chunks.length === 0) return;\r\n    \r\n    try {\r\n      setIsLoading(true);\r\n      const wavBlob = await convertToWav(chunks, audioContextRef.current?.sampleRate || AUDIO_CONFIG.SAMPLE_RATE);\r\n      \r\n      const formData = new FormData();\r\n      formData.append('audio', wavBlob, `recording_${Date.now()}.wav`);\r\n      \r\n      const response = await fetch(`${AUDIO_CONFIG.BACKEND_URL}${AUDIO_CONFIG.API_ENDPOINTS.UPLOAD}`, {\r\n        method: 'POST',\r\n        body: formData,\r\n      });\r\n      \r\n      if (!response.ok) {\r\n        throw new Error(`HTTP error! status: ${response.status}`);\r\n      }\r\n      \r\n      const result = await response.json();\r\n      console.log('Upload result:', result);\r\n      \r\n      if (result.transcription_file) {\r\n        await pollTranscription(result.transcription_file);\r\n      }\r\n      \r\n      setAudioChunks([]);\r\n    } catch (error) {\r\n      console.error('Error processing/sending audio:', error);\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  };\r\n\r\n  const pollTranscription = async (filename) => {\r\n    const maxAttempts = 30;\r\n    let attempts = 0;\r\n    \r\n    while (attempts < maxAttempts) {\r\n      try {\r\n        const response = await fetch(`${AUDIO_CONFIG.BACKEND_URL}${AUDIO_CONFIG.API_ENDPOINTS.TRANSCRIPTION}/${filename}`);\r\n        if (response.ok) {\r\n          const data = await response.json();\r\n          setTranscription(data);\r\n          return;\r\n        }\r\n        // Only log on specific errors, not 404\r\n        if (response.status !== 404) {\r\n          console.error('Polling error:', response.status);\r\n        }\r\n      } catch (error) {\r\n        console.error('Polling error:', error);\r\n      }\r\n      attempts++;\r\n      await new Promise(resolve => setTimeout(resolve, 2000)); // Increased interval to 2 seconds\r\n    }\r\n    console.log('Polling timeout reached');\r\n  };\r\n\r\n  const playTTSAudio = async () => {\r\n    if (!transcription?.tts_audio) return;\r\n    \r\n    try {\r\n      if (!audioPlayerRef.current) {\r\n        const audioUrl = `${AUDIO_CONFIG.BACKEND_URL}${AUDIO_CONFIG.API_ENDPOINTS.TTS}/${transcription.tts_audio}`;\r\n        audioPlayerRef.current = new Audio(audioUrl);\r\n      }\r\n      \r\n      setIsPlaying(true);\r\n      await audioPlayerRef.current.play();\r\n      \r\n      audioPlayerRef.current.onended = () => {\r\n        setIsPlaying(false);\r\n      };\r\n    } catch (error) {\r\n      console.error('Error playing TTS:', error);\r\n      setIsPlaying(false);\r\n    }\r\n  };\r\n\r\n  useEffect(() => {\r\n    return () => {\r\n      if (isRecording) {\r\n        stopRecording();\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  return (\r\n    <div className=\"audio-recorder\">\r\n      <button \r\n        className={`record-button ${isRecording ? 'recording' : ''}`}\r\n        onClick={toggleRecording}\r\n      >\r\n        {isRecording ? <FaMicrophoneSlash /> : <FaMicrophone />}\r\n      </button>\r\n      <div className=\"status\">\r\n        {isRecording ? (\r\n          <span className=\"recording-indicator\">\r\n            Recording {silenceDetected ? '(Silence detected)' : ''}\r\n          </span>\r\n        ) : (\r\n          <span>Click to start recording</span>\r\n        )}\r\n      </div>\r\n      \r\n      {transcription && (\r\n        <div className=\"transcription-section\">\r\n          <p className=\"transcription-text\">{transcription.full_text}</p>\r\n          <button \r\n            className={`tts-button ${isPlaying ? 'playing' : ''}`}\r\n            onClick={playTTSAudio}\r\n            disabled={isPlaying || isLoading}\r\n          >\r\n            {isLoading ? <FaSpinner className=\"spinner\" /> : <FaPlay />}\r\n            {isPlaying ? 'Playing...' : 'Play TTS'}\r\n          </button>\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default AudioRecorder;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}