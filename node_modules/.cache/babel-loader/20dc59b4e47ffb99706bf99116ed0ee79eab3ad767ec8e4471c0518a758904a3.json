{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\arunk\\\\Downloads\\\\createxyz-project\\\\ract\\\\audio-recorder\\\\src\\\\AudioRecorder.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useRef, useEffect } from 'react';\nimport { FaMicrophone, FaMicrophoneSlash, FaPlay, FaSpinner } from 'react-icons/fa';\nimport { AUDIO_CONFIG } from './config/constants';\nimport './AudioRecorder.css';\nimport { convertToWav } from './utils/audioConverter';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst AudioRecorder = () => {\n  _s();\n  var _transcription$durati, _transcription$proces, _transcription$tts_ti;\n  const [isRecording, setIsRecording] = useState(false);\n  const [audioChunks, setAudioChunks] = useState([]);\n  const [silenceDetected, setSilenceDetected] = useState(false);\n  const [silenceStartTime, setSilenceStartTime] = useState(null);\n  const [transcription, setTranscription] = useState(null);\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [isLoading, setIsLoading] = useState(false);\n  const [sessionId, setSessionId] = useState(null);\n  const [progress, setProgress] = useState('');\n  const mediaRecorderRef = useRef(null);\n  const streamRef = useRef(null);\n  const analyserRef = useRef(null);\n  const audioContextRef = useRef(null);\n  const silenceTimeoutRef = useRef(null);\n  const audioPlayerRef = useRef(null);\n  const startRecording = async () => {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: true\n      });\n      streamRef.current = stream;\n      const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n      audioContextRef.current = audioContext;\n      const analyser = audioContext.createAnalyser();\n      analyserRef.current = analyser;\n      analyser.smoothingTimeConstant = AUDIO_CONFIG.SMOOTHING_TIME_CONSTANT;\n      analyser.fftSize = 2048;\n      const source = audioContext.createMediaStreamSource(stream);\n      source.connect(analyser);\n\n      // Get supported MIME type\n      const mimeType = ['audio/webm;codecs=opus', 'audio/webm', 'audio/ogg;codecs=opus', 'audio/ogg'].find(type => MediaRecorder.isTypeSupported(type));\n      if (!mimeType) {\n        throw new Error('No supported media recording MIME type found');\n      }\n      const mediaRecorder = new MediaRecorder(stream, {\n        mimeType,\n        audioBitsPerSecond: 128000\n      });\n      mediaRecorderRef.current = mediaRecorder;\n      mediaRecorder.ondataavailable = event => {\n        if (event.data.size > 0) {\n          setAudioChunks(prevChunks => [...prevChunks, event.data]);\n        }\n      };\n      mediaRecorder.start(AUDIO_CONFIG.CHUNK_INTERVAL);\n      setIsRecording(true);\n      monitorAudioLevel();\n    } catch (err) {\n      console.error(\"Error accessing microphone:\", err);\n      alert('Error accessing microphone. Please check permissions.');\n    }\n  };\n  const stopRecording = () => {\n    if (mediaRecorderRef.current && streamRef.current) {\n      mediaRecorderRef.current.stop();\n      streamRef.current.getTracks().forEach(track => track.stop());\n      if (audioChunks.length > 0) {\n        saveAndSendAudio(audioChunks);\n      }\n      clearTimeout(silenceTimeoutRef.current);\n      setIsRecording(false);\n      setSilenceDetected(false);\n      setSilenceStartTime(null);\n      setAudioChunks([]);\n      if (audioContextRef.current) {\n        audioContextRef.current.close();\n      }\n    }\n  };\n  const toggleRecording = () => {\n    if (isRecording) {\n      stopRecording();\n    } else {\n      startRecording();\n    }\n  };\n  const monitorAudioLevel = () => {\n    if (!analyserRef.current || !isRecording) return;\n    const dataArray = new Uint8Array(analyserRef.current.frequencyBinCount);\n    analyserRef.current.getByteFrequencyData(dataArray);\n    const average = dataArray.reduce((a, b) => a + b, 0) / dataArray.length;\n    const dB = 20 * Math.log10(average / 255);\n    if (dB < AUDIO_CONFIG.SILENCE_THRESHOLD) {\n      if (!silenceDetected) {\n        setSilenceDetected(true);\n        setSilenceStartTime(Date.now());\n      } else if (Date.now() - silenceStartTime > AUDIO_CONFIG.SILENCE_DURATION) {\n        saveAndSendAudio(audioChunks);\n        setSilenceStartTime(Date.now());\n      }\n    } else {\n      setSilenceDetected(false);\n      setSilenceStartTime(null);\n    }\n    requestAnimationFrame(monitorAudioLevel);\n  };\n  const saveAndSendAudio = async chunks => {\n    if (!chunks || chunks.length === 0) return;\n    try {\n      var _audioContextRef$curr;\n      setIsLoading(true);\n      setProgress('Converting audio to WAV format...');\n      const wavBlob = await convertToWav(chunks, ((_audioContextRef$curr = audioContextRef.current) === null || _audioContextRef$curr === void 0 ? void 0 : _audioContextRef$curr.sampleRate) || AUDIO_CONFIG.SAMPLE_RATE);\n      setProgress('Sending audio to server...');\n      const formData = new FormData();\n      formData.append('audio', wavBlob, `recording_${Date.now()}.wav`);\n      const response = await fetch(`${AUDIO_CONFIG.BACKEND_URL}${AUDIO_CONFIG.API_ENDPOINTS.UPLOAD}`, {\n        method: 'POST',\n        body: formData\n      });\n      if (!response.ok) {\n        throw new Error(`Server error: ${response.status}`);\n      }\n      const result = await response.json();\n      if (!result.session_id) {\n        throw new Error('No session ID received');\n      }\n      setSessionId(result.session_id);\n      await pollTranscription(result.session_id);\n    } catch (error) {\n      console.error('Error:', error);\n      setProgress(`Error: ${error.message}`);\n      setTimeout(() => setProgress(''), 5000);\n    } finally {\n      setIsLoading(false);\n      setAudioChunks([]);\n    }\n  };\n  const pollTranscription = async sid => {\n    const maxAttempts = 60;\n    let attempts = 0;\n    const playAudioFromUrl = async url => {\n      try {\n        const audio = new Audio(url);\n        await audio.play();\n        console.log('Playing TTS audio');\n      } catch (err) {\n        console.error('Error playing TTS:', err);\n      }\n    };\n    while (attempts < maxAttempts) {\n      try {\n        const response = await fetch(`${AUDIO_CONFIG.BACKEND_URL}${AUDIO_CONFIG.API_ENDPOINTS.TRANSCRIPTION}/${sid}`);\n        console.log('Poll response:', response.status);\n        if (response.ok) {\n          const data = await response.json();\n          console.log('Transcription received:', data);\n          if (data.text && data.tts_audio) {\n            setTranscription(data);\n            setProgress(`Transcription complete: \"${data.text}\"`);\n            const audioUrl = `${AUDIO_CONFIG.BACKEND_URL}${AUDIO_CONFIG.API_ENDPOINTS.TTS}/${data.tts_audio}`;\n            await playAudioFromUrl(audioUrl);\n            return;\n          }\n        }\n      } catch (error) {\n        console.error('Polling error:', error);\n      }\n      attempts++;\n      await new Promise(resolve => setTimeout(resolve, 1000));\n      setProgress(`Processing audio... ${attempts}/${maxAttempts}`);\n    }\n    setProgress('Processing timed out. Please try again.');\n  };\n  const playTTSAudio = async ttsAudioFile => {\n    try {\n      const audioUrl = `${AUDIO_CONFIG.BACKEND_URL}${AUDIO_CONFIG.API_ENDPOINTS.TTS}/${ttsAudioFile}`;\n      audioPlayerRef.current = new Audio(audioUrl);\n      audioPlayerRef.current.onended = () => {\n        setIsPlaying(false);\n        audioPlayerRef.current = null;\n      };\n      audioPlayerRef.current.onerror = e => {\n        console.error('Error playing TTS audio:', e);\n        setIsPlaying(false);\n        audioPlayerRef.current = null;\n      };\n      setIsPlaying(true);\n      await audioPlayerRef.current.play();\n    } catch (error) {\n      console.error('Error playing TTS:', error);\n      setIsPlaying(false);\n    }\n  };\n  useEffect(() => {\n    return () => {\n      if (isRecording) {\n        stopRecording();\n      }\n    };\n  }, []);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"audio-recorder\",\n    children: [/*#__PURE__*/_jsxDEV(\"button\", {\n      className: `record-button ${isRecording ? 'recording' : ''}`,\n      onClick: toggleRecording,\n      children: isRecording ? /*#__PURE__*/_jsxDEV(FaMicrophoneSlash, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 249,\n        columnNumber: 24\n      }, this) : /*#__PURE__*/_jsxDEV(FaMicrophone, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 249,\n        columnNumber: 48\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 245,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"status\",\n      children: isRecording ? /*#__PURE__*/_jsxDEV(\"span\", {\n        className: \"recording-indicator\",\n        children: [\"Recording \", silenceDetected ? '(Silence detected)' : '']\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 253,\n        columnNumber: 11\n      }, this) : /*#__PURE__*/_jsxDEV(\"span\", {\n        children: \"Click to start recording\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 257,\n        columnNumber: 11\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 251,\n      columnNumber: 7\n    }, this), progress && /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"progress-info\",\n      children: progress\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 262,\n      columnNumber: 9\n    }, this), transcription && /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"transcription-section\",\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"processing-info\",\n        children: [/*#__PURE__*/_jsxDEV(\"h3\", {\n          children: \"Processing Details\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 270,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n          children: [\"Audio Duration: \", (_transcription$durati = transcription.duration) === null || _transcription$durati === void 0 ? void 0 : _transcription$durati.toFixed(2), \"s\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 271,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n          children: [\"Processing Time: \", (_transcription$proces = transcription.processing_time) === null || _transcription$proces === void 0 ? void 0 : _transcription$proces.toFixed(2), \"s\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 272,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n          children: [\"TTS Generation Time: \", (_transcription$tts_ti = transcription.tts_time) === null || _transcription$tts_ti === void 0 ? void 0 : _transcription$tts_ti.toFixed(2), \"s\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 273,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 269,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"transcript-container\",\n        children: [/*#__PURE__*/_jsxDEV(\"h3\", {\n          children: \"Transcription\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 277,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n          className: \"transcription-text\",\n          children: transcription.text\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 278,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 276,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 268,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 244,\n    columnNumber: 5\n  }, this);\n};\n_s(AudioRecorder, \"0XmZS9vWED7Co0SIOuMvLB8wsKs=\");\n_c = AudioRecorder;\nexport default AudioRecorder;\nvar _c;\n$RefreshReg$(_c, \"AudioRecorder\");","map":{"version":3,"names":["React","useState","useRef","useEffect","FaMicrophone","FaMicrophoneSlash","FaPlay","FaSpinner","AUDIO_CONFIG","convertToWav","jsxDEV","_jsxDEV","AudioRecorder","_s","_transcription$durati","_transcription$proces","_transcription$tts_ti","isRecording","setIsRecording","audioChunks","setAudioChunks","silenceDetected","setSilenceDetected","silenceStartTime","setSilenceStartTime","transcription","setTranscription","isPlaying","setIsPlaying","isLoading","setIsLoading","sessionId","setSessionId","progress","setProgress","mediaRecorderRef","streamRef","analyserRef","audioContextRef","silenceTimeoutRef","audioPlayerRef","startRecording","stream","navigator","mediaDevices","getUserMedia","audio","current","audioContext","window","AudioContext","webkitAudioContext","analyser","createAnalyser","smoothingTimeConstant","SMOOTHING_TIME_CONSTANT","fftSize","source","createMediaStreamSource","connect","mimeType","find","type","MediaRecorder","isTypeSupported","Error","mediaRecorder","audioBitsPerSecond","ondataavailable","event","data","size","prevChunks","start","CHUNK_INTERVAL","monitorAudioLevel","err","console","error","alert","stopRecording","stop","getTracks","forEach","track","length","saveAndSendAudio","clearTimeout","close","toggleRecording","dataArray","Uint8Array","frequencyBinCount","getByteFrequencyData","average","reduce","a","b","dB","Math","log10","SILENCE_THRESHOLD","Date","now","SILENCE_DURATION","requestAnimationFrame","chunks","_audioContextRef$curr","wavBlob","sampleRate","SAMPLE_RATE","formData","FormData","append","response","fetch","BACKEND_URL","API_ENDPOINTS","UPLOAD","method","body","ok","status","result","json","session_id","pollTranscription","message","setTimeout","sid","maxAttempts","attempts","playAudioFromUrl","url","Audio","play","log","TRANSCRIPTION","text","tts_audio","audioUrl","TTS","Promise","resolve","playTTSAudio","ttsAudioFile","onended","onerror","e","className","children","onClick","fileName","_jsxFileName","lineNumber","columnNumber","duration","toFixed","processing_time","tts_time","_c","$RefreshReg$"],"sources":["C:/Users/arunk/Downloads/createxyz-project/ract/audio-recorder/src/AudioRecorder.js"],"sourcesContent":["import React, { useState, useRef, useEffect } from 'react';\r\nimport { FaMicrophone, FaMicrophoneSlash, FaPlay, FaSpinner } from 'react-icons/fa';\r\nimport { AUDIO_CONFIG } from './config/constants';\r\nimport './AudioRecorder.css';\r\nimport { convertToWav } from './utils/audioConverter';\r\n\r\nconst AudioRecorder = () => {\r\n  const [isRecording, setIsRecording] = useState(false);\r\n  const [audioChunks, setAudioChunks] = useState([]);\r\n  const [silenceDetected, setSilenceDetected] = useState(false);\r\n  const [silenceStartTime, setSilenceStartTime] = useState(null);\r\n  const [transcription, setTranscription] = useState(null);\r\n  const [isPlaying, setIsPlaying] = useState(false);\r\n  const [isLoading, setIsLoading] = useState(false);\r\n  const [sessionId, setSessionId] = useState(null);\r\n  const [progress, setProgress] = useState('');\r\n  \r\n  const mediaRecorderRef = useRef(null);\r\n  const streamRef = useRef(null);\r\n  const analyserRef = useRef(null);\r\n  const audioContextRef = useRef(null);\r\n  const silenceTimeoutRef = useRef(null);\r\n  const audioPlayerRef = useRef(null);\r\n\r\n  const startRecording = async () => {\r\n    try {\r\n      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\r\n      streamRef.current = stream;\r\n      \r\n      const audioContext = new (window.AudioContext || window.webkitAudioContext)();\r\n      audioContextRef.current = audioContext;\r\n      \r\n      const analyser = audioContext.createAnalyser();\r\n      analyserRef.current = analyser;\r\n      analyser.smoothingTimeConstant = AUDIO_CONFIG.SMOOTHING_TIME_CONSTANT;\r\n      analyser.fftSize = 2048;\r\n      \r\n      const source = audioContext.createMediaStreamSource(stream);\r\n      source.connect(analyser);\r\n      \r\n      // Get supported MIME type\r\n      const mimeType = [\r\n        'audio/webm;codecs=opus',\r\n        'audio/webm',\r\n        'audio/ogg;codecs=opus',\r\n        'audio/ogg'\r\n      ].find(type => MediaRecorder.isTypeSupported(type));\r\n      \r\n      if (!mimeType) {\r\n        throw new Error('No supported media recording MIME type found');\r\n      }\r\n      \r\n      const mediaRecorder = new MediaRecorder(stream, {\r\n        mimeType,\r\n        audioBitsPerSecond: 128000\r\n      });\r\n      mediaRecorderRef.current = mediaRecorder;\r\n      \r\n      mediaRecorder.ondataavailable = (event) => {\r\n        if (event.data.size > 0) {\r\n          setAudioChunks((prevChunks) => [...prevChunks, event.data]);\r\n        }\r\n      };\r\n      \r\n      mediaRecorder.start(AUDIO_CONFIG.CHUNK_INTERVAL);\r\n      setIsRecording(true);\r\n      monitorAudioLevel();\r\n      \r\n    } catch (err) {\r\n      console.error(\"Error accessing microphone:\", err);\r\n      alert('Error accessing microphone. Please check permissions.');\r\n    }\r\n  };\r\n\r\n  const stopRecording = () => {\r\n    if (mediaRecorderRef.current && streamRef.current) {\r\n      mediaRecorderRef.current.stop();\r\n      streamRef.current.getTracks().forEach(track => track.stop());\r\n      \r\n      if (audioChunks.length > 0) {\r\n        saveAndSendAudio(audioChunks);\r\n      }\r\n      \r\n      clearTimeout(silenceTimeoutRef.current);\r\n      setIsRecording(false);\r\n      setSilenceDetected(false);\r\n      setSilenceStartTime(null);\r\n      setAudioChunks([]);\r\n      \r\n      if (audioContextRef.current) {\r\n        audioContextRef.current.close();\r\n      }\r\n    }\r\n  };\r\n\r\n  const toggleRecording = () => {\r\n    if (isRecording) {\r\n      stopRecording();\r\n    } else {\r\n      startRecording();\r\n    }\r\n  };\r\n\r\n  const monitorAudioLevel = () => {\r\n    if (!analyserRef.current || !isRecording) return;\r\n    \r\n    const dataArray = new Uint8Array(analyserRef.current.frequencyBinCount);\r\n    analyserRef.current.getByteFrequencyData(dataArray);\r\n    \r\n    const average = dataArray.reduce((a, b) => a + b, 0) / dataArray.length;\r\n    const dB = 20 * Math.log10(average / 255);\r\n    \r\n    if (dB < AUDIO_CONFIG.SILENCE_THRESHOLD) {\r\n      if (!silenceDetected) {\r\n        setSilenceDetected(true);\r\n        setSilenceStartTime(Date.now());\r\n      } else if (Date.now() - silenceStartTime > AUDIO_CONFIG.SILENCE_DURATION) {\r\n        saveAndSendAudio(audioChunks);\r\n        setSilenceStartTime(Date.now());\r\n      }\r\n    } else {\r\n      setSilenceDetected(false);\r\n      setSilenceStartTime(null);\r\n    }\r\n    \r\n    requestAnimationFrame(monitorAudioLevel);\r\n  };\r\n\r\n  const saveAndSendAudio = async (chunks) => {\r\n    if (!chunks || chunks.length === 0) return;\r\n    \r\n    try {\r\n      setIsLoading(true);\r\n      setProgress('Converting audio to WAV format...');\r\n      const wavBlob = await convertToWav(chunks, audioContextRef.current?.sampleRate || AUDIO_CONFIG.SAMPLE_RATE);\r\n      \r\n      setProgress('Sending audio to server...');\r\n      const formData = new FormData();\r\n      formData.append('audio', wavBlob, `recording_${Date.now()}.wav`);\r\n      \r\n      const response = await fetch(`${AUDIO_CONFIG.BACKEND_URL}${AUDIO_CONFIG.API_ENDPOINTS.UPLOAD}`, {\r\n        method: 'POST',\r\n        body: formData,\r\n      });\r\n      \r\n      if (!response.ok) {\r\n        throw new Error(`Server error: ${response.status}`);\r\n      }\r\n      \r\n      const result = await response.json();\r\n      if (!result.session_id) {\r\n        throw new Error('No session ID received');\r\n      }\r\n\r\n      setSessionId(result.session_id);\r\n      await pollTranscription(result.session_id);\r\n      \r\n    } catch (error) {\r\n      console.error('Error:', error);\r\n      setProgress(`Error: ${error.message}`);\r\n      setTimeout(() => setProgress(''), 5000);\r\n    } finally {\r\n      setIsLoading(false);\r\n      setAudioChunks([]);\r\n    }\r\n  };\r\n\r\n  const pollTranscription = async (sid) => {\r\n    const maxAttempts = 60;\r\n    let attempts = 0;\r\n\r\n    const playAudioFromUrl = async (url) => {\r\n      try {\r\n        const audio = new Audio(url);\r\n        await audio.play();\r\n        console.log('Playing TTS audio');\r\n      } catch (err) {\r\n        console.error('Error playing TTS:', err);\r\n      }\r\n    };\r\n    \r\n    while (attempts < maxAttempts) {\r\n      try {\r\n        const response = await fetch(`${AUDIO_CONFIG.BACKEND_URL}${AUDIO_CONFIG.API_ENDPOINTS.TRANSCRIPTION}/${sid}`);\r\n        console.log('Poll response:', response.status);\r\n        \r\n        if (response.ok) {\r\n          const data = await response.json();\r\n          console.log('Transcription received:', data);\r\n          \r\n          if (data.text && data.tts_audio) {\r\n            setTranscription(data);\r\n            setProgress(`Transcription complete: \"${data.text}\"`);\r\n            \r\n            const audioUrl = `${AUDIO_CONFIG.BACKEND_URL}${AUDIO_CONFIG.API_ENDPOINTS.TTS}/${data.tts_audio}`;\r\n            await playAudioFromUrl(audioUrl);\r\n            return;\r\n          }\r\n        }\r\n      } catch (error) {\r\n        console.error('Polling error:', error);\r\n      }\r\n      \r\n      attempts++;\r\n      await new Promise(resolve => setTimeout(resolve, 1000));\r\n      setProgress(`Processing audio... ${attempts}/${maxAttempts}`);\r\n    }\r\n    setProgress('Processing timed out. Please try again.');\r\n  };\r\n\r\n  const playTTSAudio = async (ttsAudioFile) => {\r\n    try {\r\n      const audioUrl = `${AUDIO_CONFIG.BACKEND_URL}${AUDIO_CONFIG.API_ENDPOINTS.TTS}/${ttsAudioFile}`;\r\n      audioPlayerRef.current = new Audio(audioUrl);\r\n      \r\n      audioPlayerRef.current.onended = () => {\r\n        setIsPlaying(false);\r\n        audioPlayerRef.current = null;\r\n      };\r\n\r\n      audioPlayerRef.current.onerror = (e) => {\r\n        console.error('Error playing TTS audio:', e);\r\n        setIsPlaying(false);\r\n        audioPlayerRef.current = null;\r\n      };\r\n\r\n      setIsPlaying(true);\r\n      await audioPlayerRef.current.play();\r\n    } catch (error) {\r\n      console.error('Error playing TTS:', error);\r\n      setIsPlaying(false);\r\n    }\r\n  };\r\n\r\n  useEffect(() => {\r\n    return () => {\r\n      if (isRecording) {\r\n        stopRecording();\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  return (\r\n    <div className=\"audio-recorder\">\r\n      <button \r\n        className={`record-button ${isRecording ? 'recording' : ''}`}\r\n        onClick={toggleRecording}\r\n      >\r\n        {isRecording ? <FaMicrophoneSlash /> : <FaMicrophone />}\r\n      </button>\r\n      <div className=\"status\">\r\n        {isRecording ? (\r\n          <span className=\"recording-indicator\">\r\n            Recording {silenceDetected ? '(Silence detected)' : ''}\r\n          </span>\r\n        ) : (\r\n          <span>Click to start recording</span>\r\n        )}\r\n      </div>\r\n      \r\n      {progress && (\r\n        <div className=\"progress-info\">\r\n          {progress}\r\n        </div>\r\n      )}\r\n      \r\n      {transcription && (\r\n        <div className=\"transcription-section\">\r\n          <div className=\"processing-info\">\r\n            <h3>Processing Details</h3>\r\n            <p>Audio Duration: {transcription.duration?.toFixed(2)}s</p>\r\n            <p>Processing Time: {transcription.processing_time?.toFixed(2)}s</p>\r\n            <p>TTS Generation Time: {transcription.tts_time?.toFixed(2)}s</p>\r\n          </div>\r\n          \r\n          <div className=\"transcript-container\">\r\n            <h3>Transcription</h3>\r\n            <p className=\"transcription-text\">{transcription.text}</p>\r\n          </div>\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default AudioRecorder;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}