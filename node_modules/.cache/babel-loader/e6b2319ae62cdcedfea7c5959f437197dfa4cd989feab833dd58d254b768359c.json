{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\arunk\\\\Downloads\\\\createxyz-project\\\\ract\\\\audio-recorder\\\\src\\\\AudioRecorder.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useRef, useEffect } from 'react';\nimport { FaMicrophone, FaMicrophoneSlash } from 'react-icons/fa';\nimport { AUDIO_CONFIG } from './config/constants';\nimport './AudioRecorder.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst AudioRecorder = () => {\n  _s();\n  const [isRecording, setIsRecording] = useState(false);\n  const [audioChunks, setAudioChunks] = useState([]);\n  const [silenceDetected, setSilenceDetected] = useState(false);\n  const [silenceStartTime, setSilenceStartTime] = useState(null);\n  const mediaRecorderRef = useRef(null);\n  const streamRef = useRef(null);\n  const analyserRef = useRef(null);\n  const audioContextRef = useRef(null);\n  const silenceTimeoutRef = useRef(null);\n  const startRecording = async () => {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: true\n      });\n      streamRef.current = stream;\n      const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n      audioContextRef.current = audioContext;\n      const analyser = audioContext.createAnalyser();\n      analyserRef.current = analyser;\n      analyser.smoothingTimeConstant = 0.3;\n      analyser.fftSize = 2048;\n      const source = audioContext.createMediaStreamSource(stream);\n      source.connect(analyser);\n      const mediaRecorder = new MediaRecorder(stream, {\n        mimeType: 'audio/wav'\n      });\n      mediaRecorderRef.current = mediaRecorder;\n      mediaRecorder.ondataavailable = event => {\n        if (event.data.size > 0) {\n          setAudioChunks(prevChunks => {\n            const newChunks = [...prevChunks, event.data];\n            if (newChunks.length >= 5) {\n              saveAndSendAudio(newChunks);\n              return [];\n            }\n            return newChunks;\n          });\n        }\n      };\n      mediaRecorder.start(AUDIO_CONFIG.CHUNK_INTERVAL);\n      setIsRecording(true);\n      monitorAudioLevel();\n    } catch (err) {\n      console.error(\"Error accessing microphone:\", err);\n    }\n  };\n  const stopRecording = () => {\n    if (mediaRecorderRef.current && streamRef.current) {\n      mediaRecorderRef.current.stop();\n      streamRef.current.getTracks().forEach(track => track.stop());\n      if (audioChunks.length > 0) {\n        saveAndSendAudio(audioChunks);\n      }\n      clearTimeout(silenceTimeoutRef.current);\n      setIsRecording(false);\n      setSilenceDetected(false);\n      setSilenceStartTime(null);\n      setAudioChunks([]);\n      if (audioContextRef.current) {\n        audioContextRef.current.close();\n      }\n    }\n  };\n  const toggleRecording = () => {\n    if (isRecording) {\n      stopRecording();\n    } else {\n      startRecording();\n    }\n  };\n  const monitorAudioLevel = () => {\n    if (!analyserRef.current || !isRecording) return;\n    const dataArray = new Uint8Array(analyserRef.current.frequencyBinCount);\n    analyserRef.current.getByteFrequencyData(dataArray);\n    const average = dataArray.reduce((a, b) => a + b, 0) / dataArray.length;\n    const dB = 20 * Math.log10(average / 255);\n    if (dB < AUDIO_CONFIG.SILENCE_THRESHOLD) {\n      if (!silenceDetected) {\n        setSilenceDetected(true);\n        setSilenceStartTime(Date.now());\n      } else if (Date.now() - silenceStartTime > AUDIO_CONFIG.SILENCE_DURATION) {\n        saveAndSendAudio(audioChunks);\n        setSilenceStartTime(Date.now());\n      }\n    } else {\n      setSilenceDetected(false);\n      setSilenceStartTime(null);\n    }\n    requestAnimationFrame(monitorAudioLevel);\n  };\n  const saveAndSendAudio = async chunks => {\n    if (!chunks || chunks.length === 0) return;\n    const audioBlob = new Blob(chunks, {\n      type: 'audio/wav'\n    });\n    const formData = new FormData();\n    formData.append('audio', audioBlob, `recording_${Date.now()}.wav`);\n    try {\n      const response = await fetch(AUDIO_CONFIG.BACKEND_URL, {\n        method: 'POST',\n        body: formData\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      setAudioChunks([]);\n    } catch (error) {\n      console.error('Error sending audio:', error);\n    }\n  };\n  useEffect(() => {\n    return () => {\n      if (isRecording) {\n        stopRecording();\n      }\n    };\n  }, []);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"audio-recorder\",\n    children: [/*#__PURE__*/_jsxDEV(\"button\", {\n      className: `record-button ${isRecording ? 'recording' : ''}`,\n      onClick: toggleRecording,\n      children: isRecording ? /*#__PURE__*/_jsxDEV(FaMicrophoneSlash, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 151,\n        columnNumber: 24\n      }, this) : /*#__PURE__*/_jsxDEV(FaMicrophone, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 151,\n        columnNumber: 48\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 147,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"status\",\n      children: isRecording ? /*#__PURE__*/_jsxDEV(\"span\", {\n        className: \"recording-indicator\",\n        children: [\"Recording \", silenceDetected ? '(Silence detected)' : '']\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 155,\n        columnNumber: 11\n      }, this) : /*#__PURE__*/_jsxDEV(\"span\", {\n        children: \"Click to start recording\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 159,\n        columnNumber: 11\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 153,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 146,\n    columnNumber: 5\n  }, this);\n};\n_s(AudioRecorder, \"yEVEE+tbVIRce7585u8v00ku7RE=\");\n_c = AudioRecorder;\nexport default AudioRecorder;\nvar _c;\n$RefreshReg$(_c, \"AudioRecorder\");","map":{"version":3,"names":["React","useState","useRef","useEffect","FaMicrophone","FaMicrophoneSlash","AUDIO_CONFIG","jsxDEV","_jsxDEV","AudioRecorder","_s","isRecording","setIsRecording","audioChunks","setAudioChunks","silenceDetected","setSilenceDetected","silenceStartTime","setSilenceStartTime","mediaRecorderRef","streamRef","analyserRef","audioContextRef","silenceTimeoutRef","startRecording","stream","navigator","mediaDevices","getUserMedia","audio","current","audioContext","window","AudioContext","webkitAudioContext","analyser","createAnalyser","smoothingTimeConstant","fftSize","source","createMediaStreamSource","connect","mediaRecorder","MediaRecorder","mimeType","ondataavailable","event","data","size","prevChunks","newChunks","length","saveAndSendAudio","start","CHUNK_INTERVAL","monitorAudioLevel","err","console","error","stopRecording","stop","getTracks","forEach","track","clearTimeout","close","toggleRecording","dataArray","Uint8Array","frequencyBinCount","getByteFrequencyData","average","reduce","a","b","dB","Math","log10","SILENCE_THRESHOLD","Date","now","SILENCE_DURATION","requestAnimationFrame","chunks","audioBlob","Blob","type","formData","FormData","append","response","fetch","BACKEND_URL","method","body","ok","Error","status","className","children","onClick","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/arunk/Downloads/createxyz-project/ract/audio-recorder/src/AudioRecorder.js"],"sourcesContent":["import React, { useState, useRef, useEffect } from 'react';\r\nimport { FaMicrophone, FaMicrophoneSlash } from 'react-icons/fa';\r\nimport { AUDIO_CONFIG } from './config/constants';\r\nimport './AudioRecorder.css';\r\n\r\nconst AudioRecorder = () => {\r\n  const [isRecording, setIsRecording] = useState(false);\r\n  const [audioChunks, setAudioChunks] = useState([]);\r\n  const [silenceDetected, setSilenceDetected] = useState(false);\r\n  const [silenceStartTime, setSilenceStartTime] = useState(null);\r\n  \r\n  const mediaRecorderRef = useRef(null);\r\n  const streamRef = useRef(null);\r\n  const analyserRef = useRef(null);\r\n  const audioContextRef = useRef(null);\r\n  const silenceTimeoutRef = useRef(null);\r\n\r\n  const startRecording = async () => {\r\n    try {\r\n      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\r\n      streamRef.current = stream;\r\n      \r\n      const audioContext = new (window.AudioContext || window.webkitAudioContext)();\r\n      audioContextRef.current = audioContext;\r\n      \r\n      const analyser = audioContext.createAnalyser();\r\n      analyserRef.current = analyser;\r\n      analyser.smoothingTimeConstant = 0.3;\r\n      analyser.fftSize = 2048;\r\n      \r\n      const source = audioContext.createMediaStreamSource(stream);\r\n      source.connect(analyser);\r\n      \r\n      const mediaRecorder = new MediaRecorder(stream, {\r\n        mimeType: 'audio/wav'\r\n      });\r\n      mediaRecorderRef.current = mediaRecorder;\r\n      \r\n      mediaRecorder.ondataavailable = (event) => {\r\n        if (event.data.size > 0) {\r\n          setAudioChunks((prevChunks) => {\r\n            const newChunks = [...prevChunks, event.data];\r\n            if (newChunks.length >= 5) {\r\n              saveAndSendAudio(newChunks);\r\n              return [];\r\n            }\r\n            return newChunks;\r\n          });\r\n        }\r\n      };\r\n      \r\n      mediaRecorder.start(AUDIO_CONFIG.CHUNK_INTERVAL);\r\n      setIsRecording(true);\r\n      monitorAudioLevel();\r\n      \r\n    } catch (err) {\r\n      console.error(\"Error accessing microphone:\", err);\r\n    }\r\n  };\r\n\r\n  const stopRecording = () => {\r\n    if (mediaRecorderRef.current && streamRef.current) {\r\n      mediaRecorderRef.current.stop();\r\n      streamRef.current.getTracks().forEach(track => track.stop());\r\n      \r\n      if (audioChunks.length > 0) {\r\n        saveAndSendAudio(audioChunks);\r\n      }\r\n      \r\n      clearTimeout(silenceTimeoutRef.current);\r\n      setIsRecording(false);\r\n      setSilenceDetected(false);\r\n      setSilenceStartTime(null);\r\n      setAudioChunks([]);\r\n      \r\n      if (audioContextRef.current) {\r\n        audioContextRef.current.close();\r\n      }\r\n    }\r\n  };\r\n\r\n  const toggleRecording = () => {\r\n    if (isRecording) {\r\n      stopRecording();\r\n    } else {\r\n      startRecording();\r\n    }\r\n  };\r\n\r\n  const monitorAudioLevel = () => {\r\n    if (!analyserRef.current || !isRecording) return;\r\n    \r\n    const dataArray = new Uint8Array(analyserRef.current.frequencyBinCount);\r\n    analyserRef.current.getByteFrequencyData(dataArray);\r\n    \r\n    const average = dataArray.reduce((a, b) => a + b, 0) / dataArray.length;\r\n    const dB = 20 * Math.log10(average / 255);\r\n    \r\n    if (dB < AUDIO_CONFIG.SILENCE_THRESHOLD) {\r\n      if (!silenceDetected) {\r\n        setSilenceDetected(true);\r\n        setSilenceStartTime(Date.now());\r\n      } else if (Date.now() - silenceStartTime > AUDIO_CONFIG.SILENCE_DURATION) {\r\n        saveAndSendAudio(audioChunks);\r\n        setSilenceStartTime(Date.now());\r\n      }\r\n    } else {\r\n      setSilenceDetected(false);\r\n      setSilenceStartTime(null);\r\n    }\r\n    \r\n    requestAnimationFrame(monitorAudioLevel);\r\n  };\r\n\r\n  const saveAndSendAudio = async (chunks) => {\r\n    if (!chunks || chunks.length === 0) return;\r\n    \r\n    const audioBlob = new Blob(chunks, { type: 'audio/wav' });\r\n    const formData = new FormData();\r\n    formData.append('audio', audioBlob, `recording_${Date.now()}.wav`);\r\n    \r\n    try {\r\n      const response = await fetch(AUDIO_CONFIG.BACKEND_URL, {\r\n        method: 'POST',\r\n        body: formData,\r\n      });\r\n      \r\n      if (!response.ok) {\r\n        throw new Error(`HTTP error! status: ${response.status}`);\r\n      }\r\n      setAudioChunks([]);\r\n    } catch (error) {\r\n      console.error('Error sending audio:', error);\r\n    }\r\n  };\r\n\r\n  useEffect(() => {\r\n    return () => {\r\n      if (isRecording) {\r\n        stopRecording();\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  return (\r\n    <div className=\"audio-recorder\">\r\n      <button \r\n        className={`record-button ${isRecording ? 'recording' : ''}`}\r\n        onClick={toggleRecording}\r\n      >\r\n        {isRecording ? <FaMicrophoneSlash /> : <FaMicrophone />}\r\n      </button>\r\n      <div className=\"status\">\r\n        {isRecording ? (\r\n          <span className=\"recording-indicator\">\r\n            Recording {silenceDetected ? '(Silence detected)' : ''}\r\n          </span>\r\n        ) : (\r\n          <span>Click to start recording</span>\r\n        )}\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default AudioRecorder;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}