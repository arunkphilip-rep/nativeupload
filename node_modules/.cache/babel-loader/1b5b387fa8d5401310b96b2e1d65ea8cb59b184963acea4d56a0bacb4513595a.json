{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\arunk\\\\Downloads\\\\createxyz-project\\\\ract\\\\audio-recorder\\\\src\\\\AudioRecorder.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useRef, useEffect } from 'react';\nimport { FaMicrophone, FaMicrophoneSlash } from 'react-icons/fa';\nimport { AUDIO_CONFIG } from './config/constants';\nimport './AudioRecorder.css';\nimport { convertToWav } from './utils/audioConverter';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst AudioRecorder = () => {\n  _s();\n  const [isRecording, setIsRecording] = useState(false);\n  const [audioChunks, setAudioChunks] = useState([]);\n  const [silenceDetected, setSilenceDetected] = useState(false);\n  const [silenceStartTime, setSilenceStartTime] = useState(null);\n  const mediaRecorderRef = useRef(null);\n  const streamRef = useRef(null);\n  const analyserRef = useRef(null);\n  const audioContextRef = useRef(null);\n  const silenceTimeoutRef = useRef(null);\n  const startRecording = async () => {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: true\n      });\n      streamRef.current = stream;\n      const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n      audioContextRef.current = audioContext;\n      const analyser = audioContext.createAnalyser();\n      analyserRef.current = analyser;\n      analyser.smoothingTimeConstant = AUDIO_CONFIG.SMOOTHING_TIME_CONSTANT;\n      analyser.fftSize = 2048;\n      const source = audioContext.createMediaStreamSource(stream);\n      source.connect(analyser);\n\n      // Get supported MIME type\n      const mimeType = ['audio/webm;codecs=opus', 'audio/webm', 'audio/ogg;codecs=opus', 'audio/ogg'].find(type => MediaRecorder.isTypeSupported(type));\n      if (!mimeType) {\n        throw new Error('No supported media recording MIME type found');\n      }\n      const mediaRecorder = new MediaRecorder(stream, {\n        mimeType,\n        audioBitsPerSecond: 128000\n      });\n      mediaRecorderRef.current = mediaRecorder;\n      mediaRecorder.ondataavailable = event => {\n        if (event.data.size > 0) {\n          setAudioChunks(prevChunks => [...prevChunks, event.data]);\n        }\n      };\n      mediaRecorder.start(AUDIO_CONFIG.CHUNK_INTERVAL);\n      setIsRecording(true);\n      monitorAudioLevel();\n    } catch (err) {\n      console.error(\"Error accessing microphone:\", err);\n      alert('Error accessing microphone. Please check permissions.');\n    }\n  };\n  const stopRecording = () => {\n    if (mediaRecorderRef.current && streamRef.current) {\n      mediaRecorderRef.current.stop();\n      streamRef.current.getTracks().forEach(track => track.stop());\n      if (audioChunks.length > 0) {\n        saveAndSendAudio(audioChunks);\n      }\n      clearTimeout(silenceTimeoutRef.current);\n      setIsRecording(false);\n      setSilenceDetected(false);\n      setSilenceStartTime(null);\n      setAudioChunks([]);\n      if (audioContextRef.current) {\n        audioContextRef.current.close();\n      }\n    }\n  };\n  const toggleRecording = () => {\n    if (isRecording) {\n      stopRecording();\n    } else {\n      startRecording();\n    }\n  };\n  const monitorAudioLevel = () => {\n    if (!analyserRef.current || !isRecording) return;\n    const dataArray = new Uint8Array(analyserRef.current.frequencyBinCount);\n    analyserRef.current.getByteFrequencyData(dataArray);\n    const average = dataArray.reduce((a, b) => a + b, 0) / dataArray.length;\n    const dB = 20 * Math.log10(average / 255);\n    if (dB < AUDIO_CONFIG.SILENCE_THRESHOLD) {\n      if (!silenceDetected) {\n        setSilenceDetected(true);\n        setSilenceStartTime(Date.now());\n      } else if (Date.now() - silenceStartTime > AUDIO_CONFIG.SILENCE_DURATION) {\n        saveAndSendAudio(audioChunks);\n        setSilenceStartTime(Date.now());\n      }\n    } else {\n      setSilenceDetected(false);\n      setSilenceStartTime(null);\n    }\n    requestAnimationFrame(monitorAudioLevel);\n  };\n  const saveAndSendAudio = async chunks => {\n    if (!chunks || chunks.length === 0) return;\n    try {\n      var _audioContextRef$curr;\n      const wavBlob = await convertToWav(chunks, ((_audioContextRef$curr = audioContextRef.current) === null || _audioContextRef$curr === void 0 ? void 0 : _audioContextRef$curr.sampleRate) || AUDIO_CONFIG.SAMPLE_RATE);\n      console.log('WAV blob created:', wavBlob.size, 'bytes');\n      const formData = new FormData();\n      formData.append('audio', wavBlob, `recording_${Date.now()}.wav`);\n      const response = await fetch(AUDIO_CONFIG.BACKEND_URL, {\n        method: 'POST',\n        body: formData\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      console.log('Audio sent successfully');\n      setAudioChunks([]);\n    } catch (error) {\n      console.error('Error processing/sending audio:', error);\n    }\n  };\n  useEffect(() => {\n    return () => {\n      if (isRecording) {\n        stopRecording();\n      }\n    };\n  }, []);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"audio-recorder\",\n    children: [/*#__PURE__*/_jsxDEV(\"button\", {\n      className: `record-button ${isRecording ? 'recording' : ''}`,\n      onClick: toggleRecording,\n      children: isRecording ? /*#__PURE__*/_jsxDEV(FaMicrophoneSlash, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 163,\n        columnNumber: 24\n      }, this) : /*#__PURE__*/_jsxDEV(FaMicrophone, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 163,\n        columnNumber: 48\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 159,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"status\",\n      children: isRecording ? /*#__PURE__*/_jsxDEV(\"span\", {\n        className: \"recording-indicator\",\n        children: [\"Recording \", silenceDetected ? '(Silence detected)' : '']\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 167,\n        columnNumber: 11\n      }, this) : /*#__PURE__*/_jsxDEV(\"span\", {\n        children: \"Click to start recording\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 171,\n        columnNumber: 11\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 165,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 158,\n    columnNumber: 5\n  }, this);\n};\n_s(AudioRecorder, \"yEVEE+tbVIRce7585u8v00ku7RE=\");\n_c = AudioRecorder;\nexport default AudioRecorder;\nvar _c;\n$RefreshReg$(_c, \"AudioRecorder\");","map":{"version":3,"names":["React","useState","useRef","useEffect","FaMicrophone","FaMicrophoneSlash","AUDIO_CONFIG","convertToWav","jsxDEV","_jsxDEV","AudioRecorder","_s","isRecording","setIsRecording","audioChunks","setAudioChunks","silenceDetected","setSilenceDetected","silenceStartTime","setSilenceStartTime","mediaRecorderRef","streamRef","analyserRef","audioContextRef","silenceTimeoutRef","startRecording","stream","navigator","mediaDevices","getUserMedia","audio","current","audioContext","window","AudioContext","webkitAudioContext","analyser","createAnalyser","smoothingTimeConstant","SMOOTHING_TIME_CONSTANT","fftSize","source","createMediaStreamSource","connect","mimeType","find","type","MediaRecorder","isTypeSupported","Error","mediaRecorder","audioBitsPerSecond","ondataavailable","event","data","size","prevChunks","start","CHUNK_INTERVAL","monitorAudioLevel","err","console","error","alert","stopRecording","stop","getTracks","forEach","track","length","saveAndSendAudio","clearTimeout","close","toggleRecording","dataArray","Uint8Array","frequencyBinCount","getByteFrequencyData","average","reduce","a","b","dB","Math","log10","SILENCE_THRESHOLD","Date","now","SILENCE_DURATION","requestAnimationFrame","chunks","_audioContextRef$curr","wavBlob","sampleRate","SAMPLE_RATE","log","formData","FormData","append","response","fetch","BACKEND_URL","method","body","ok","status","className","children","onClick","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/arunk/Downloads/createxyz-project/ract/audio-recorder/src/AudioRecorder.js"],"sourcesContent":["import React, { useState, useRef, useEffect } from 'react';\r\nimport { FaMicrophone, FaMicrophoneSlash } from 'react-icons/fa';\r\nimport { AUDIO_CONFIG } from './config/constants';\r\nimport './AudioRecorder.css';\r\nimport { convertToWav } from './utils/audioConverter';\r\n\r\nconst AudioRecorder = () => {\r\n  const [isRecording, setIsRecording] = useState(false);\r\n  const [audioChunks, setAudioChunks] = useState([]);\r\n  const [silenceDetected, setSilenceDetected] = useState(false);\r\n  const [silenceStartTime, setSilenceStartTime] = useState(null);\r\n  \r\n  const mediaRecorderRef = useRef(null);\r\n  const streamRef = useRef(null);\r\n  const analyserRef = useRef(null);\r\n  const audioContextRef = useRef(null);\r\n  const silenceTimeoutRef = useRef(null);\r\n\r\n  const startRecording = async () => {\r\n    try {\r\n      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\r\n      streamRef.current = stream;\r\n      \r\n      const audioContext = new (window.AudioContext || window.webkitAudioContext)();\r\n      audioContextRef.current = audioContext;\r\n      \r\n      const analyser = audioContext.createAnalyser();\r\n      analyserRef.current = analyser;\r\n      analyser.smoothingTimeConstant = AUDIO_CONFIG.SMOOTHING_TIME_CONSTANT;\r\n      analyser.fftSize = 2048;\r\n      \r\n      const source = audioContext.createMediaStreamSource(stream);\r\n      source.connect(analyser);\r\n      \r\n      // Get supported MIME type\r\n      const mimeType = [\r\n        'audio/webm;codecs=opus',\r\n        'audio/webm',\r\n        'audio/ogg;codecs=opus',\r\n        'audio/ogg'\r\n      ].find(type => MediaRecorder.isTypeSupported(type));\r\n      \r\n      if (!mimeType) {\r\n        throw new Error('No supported media recording MIME type found');\r\n      }\r\n      \r\n      const mediaRecorder = new MediaRecorder(stream, {\r\n        mimeType,\r\n        audioBitsPerSecond: 128000\r\n      });\r\n      mediaRecorderRef.current = mediaRecorder;\r\n      \r\n      mediaRecorder.ondataavailable = (event) => {\r\n        if (event.data.size > 0) {\r\n          setAudioChunks((prevChunks) => [...prevChunks, event.data]);\r\n        }\r\n      };\r\n      \r\n      mediaRecorder.start(AUDIO_CONFIG.CHUNK_INTERVAL);\r\n      setIsRecording(true);\r\n      monitorAudioLevel();\r\n      \r\n    } catch (err) {\r\n      console.error(\"Error accessing microphone:\", err);\r\n      alert('Error accessing microphone. Please check permissions.');\r\n    }\r\n  };\r\n\r\n  const stopRecording = () => {\r\n    if (mediaRecorderRef.current && streamRef.current) {\r\n      mediaRecorderRef.current.stop();\r\n      streamRef.current.getTracks().forEach(track => track.stop());\r\n      \r\n      if (audioChunks.length > 0) {\r\n        saveAndSendAudio(audioChunks);\r\n      }\r\n      \r\n      clearTimeout(silenceTimeoutRef.current);\r\n      setIsRecording(false);\r\n      setSilenceDetected(false);\r\n      setSilenceStartTime(null);\r\n      setAudioChunks([]);\r\n      \r\n      if (audioContextRef.current) {\r\n        audioContextRef.current.close();\r\n      }\r\n    }\r\n  };\r\n\r\n  const toggleRecording = () => {\r\n    if (isRecording) {\r\n      stopRecording();\r\n    } else {\r\n      startRecording();\r\n    }\r\n  };\r\n\r\n  const monitorAudioLevel = () => {\r\n    if (!analyserRef.current || !isRecording) return;\r\n    \r\n    const dataArray = new Uint8Array(analyserRef.current.frequencyBinCount);\r\n    analyserRef.current.getByteFrequencyData(dataArray);\r\n    \r\n    const average = dataArray.reduce((a, b) => a + b, 0) / dataArray.length;\r\n    const dB = 20 * Math.log10(average / 255);\r\n    \r\n    if (dB < AUDIO_CONFIG.SILENCE_THRESHOLD) {\r\n      if (!silenceDetected) {\r\n        setSilenceDetected(true);\r\n        setSilenceStartTime(Date.now());\r\n      } else if (Date.now() - silenceStartTime > AUDIO_CONFIG.SILENCE_DURATION) {\r\n        saveAndSendAudio(audioChunks);\r\n        setSilenceStartTime(Date.now());\r\n      }\r\n    } else {\r\n      setSilenceDetected(false);\r\n      setSilenceStartTime(null);\r\n    }\r\n    \r\n    requestAnimationFrame(monitorAudioLevel);\r\n  };\r\n\r\n  const saveAndSendAudio = async (chunks) => {\r\n    if (!chunks || chunks.length === 0) return;\r\n    \r\n    try {\r\n      const wavBlob = await convertToWav(chunks, audioContextRef.current?.sampleRate || AUDIO_CONFIG.SAMPLE_RATE);\r\n      console.log('WAV blob created:', wavBlob.size, 'bytes');\r\n      \r\n      const formData = new FormData();\r\n      formData.append('audio', wavBlob, `recording_${Date.now()}.wav`);\r\n      \r\n      const response = await fetch(AUDIO_CONFIG.BACKEND_URL, {\r\n        method: 'POST',\r\n        body: formData,\r\n      });\r\n      \r\n      if (!response.ok) {\r\n        throw new Error(`HTTP error! status: ${response.status}`);\r\n      }\r\n      \r\n      console.log('Audio sent successfully');\r\n      setAudioChunks([]);\r\n    } catch (error) {\r\n      console.error('Error processing/sending audio:', error);\r\n    }\r\n  };\r\n\r\n  useEffect(() => {\r\n    return () => {\r\n      if (isRecording) {\r\n        stopRecording();\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  return (\r\n    <div className=\"audio-recorder\">\r\n      <button \r\n        className={`record-button ${isRecording ? 'recording' : ''}`}\r\n        onClick={toggleRecording}\r\n      >\r\n        {isRecording ? <FaMicrophoneSlash /> : <FaMicrophone />}\r\n      </button>\r\n      <div className=\"status\">\r\n        {isRecording ? (\r\n          <span className=\"recording-indicator\">\r\n            Recording {silenceDetected ? '(Silence detected)' : ''}\r\n          </span>\r\n        ) : (\r\n          <span>Click to start recording</span>\r\n        )}\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default AudioRecorder;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}